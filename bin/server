#!/usr/bin/env node
'use strict';

var http = require('http');
var path = require('path');
var url = require('url');
var fs = require('fs');
var uuid = require('uuid');
var _ = require('lodash');
var async = require('async');
var soap = require('soap');

// mock data generated by mockaroo.com
var products = require('../data/products.json');
var productsById = {}; _.each(products, function(p) { productsById[p.id] = p; });

var soapPort = process.env.SOAP_PORT || 3000;
var soapBaseAddress = process.env.SOAP_BASE_ADDRESS || 'http://0.0.0.0:' + soapPort;
var timeout = process.env.TIMEOUT || 20 * 60 * 1000; // 20 mins

var rawWsdl = fs.readFileSync(path.resolve(__dirname, '..', 'services.wsdl'), 'utf8');
var wsdl = rawWsdl.replace(/{{baseAddress}}/g, soapBaseAddress);

var orders = {};
var transactionCosts = 0.99;
var shipmentCosts = 5.90;



var toSoapError = function(err) {
  console.error(err);

  return {
    Fault: {
      Code: {
        Value: "soap:Sender"
        //, Subcode: { value: "soap:Error" }
      },
      Reason: { Text: err.soapText || err.message || err.toString() }
    }
  };
};



// prepare SOAP server
var server = http.createServer(function(req, res) {
  var parsedUrl = url.parse(req.url);

  if (parsedUrl.pathname === '/') {
    res.writeHead(200, { 'Content-Type': 'application/xml' });

    var tailoredWsdl = wsdl;

    if (!process.env.SOAP_BASE_ADDRESS) {
      tailoredWsdl = rawWsdl.replace(/{{baseAddress}}/g, 'http://' + req.headers.host);
    }

    res.write(tailoredWsdl);
  } else {
    res.writeHead(404, { 'Content-Type': 'text/plain' });

    res.write('Not Found: ' + req.url);
  }

  res.end();
});

server.setTimeout(timeout);
server.log = console.log;
server.on('error', function(err) {
  if (err) throw err;
});



// register SOAP endpoints for inventory service
var checkAvailability = function(input, delay, callback) {
  if (!input.productId) return callback(new Error('product ID missing'));

  if (!productsById[input.productId]) return callback(new Error('product missing'));

  var output = {
    product: _.assign(_.clone(productsById[input.productId]), { status: {} })
  };

  if (output.product.available) {
    output.product.status.currentAvailability = 'available';
  } else {
    output.product.status.currentAvailability = 'not available';
    output.product.status.availableAgainInDays = output.product.days;
  }

  delete output.product.available;
  delete output.product.days;

  setTimeout(function() {
    callback(null, output);
  }, delay);
};

var inventoryPort = { InventoryService: {} };

inventoryPort.InventoryService.InventoryPort = {
  checkAvailability: function(input, callback, headers) {
    input = input || {};

    var delay = input.delay || process.env.RESPONSE_DELAY || 7 * 1000; // 7 seconds

    checkAvailability(input, delay, function(err, output) {
      if (err) throw toSoapError(err);

      callback(output);
    });
  },
  checkAvailabilityAsync: function(input, callback, headers) {
    input = input || {};

    if (!input.callbackUrl) throw toSoapError(new Error('callback URL missing'));

    if (!_.isArray(input.productId)) throw toSoapError(new Error('product IDs missing'));

    var delay = input.delay || process.env.RESPONSE_DELAY || 15 * 1000; // 15 seconds

    var response = {
      customerId: input.customerId,
      productList: []
    };

    async.each(input.productId, function(id, callback) {
      checkAvailability({ productId: id }, delay, function(err, output) {
        if (err) return callback(err);

        response.productList.push(output.product);

        callback();
      });
    }, function(err) {
      if (err) return console.error(err);

      soap.createClient(input.callbackUrl + '?wsdl', function(err, client) {
        if (err) return console.error(err);

        client.onFinishCheckAvailability(response, function(err, result) {
          if (err) return console.error(err);
        });
      });
    });

    //callback({ checkAvailabilityAsyncResponse: { estimatedDurationInMillis: responseDelay + _.random(1, 99) } });
    callback();
  },
  listProducts: function(input, callback, headers) {
    input = input || {};

    if (input.limit) input.limit = parseInt(input.limit);

    var count = 0;

    var output = { productList: { product: [] } };

    _.each(products, function(p) {
      if (_.isNumber(input.limit) && input.limit <= count) return;

      p = _.clone(p);

      delete p.available;
      delete p.days;

      output.productList.product.push(p);

      count++;
    });

    callback(output);
  }
};

soap.listen(server, '/InventoryService/InventoryPort', inventoryPort, wsdl);



// register SOAP endpoints for order service
var orderPort = { OrderService: {} };

orderPort.OrderService.OrderPort = {
  storeOrderDetails: function(input, callback, headers) {
    input = input || {};

    input.orderId = input.orderId || uuid.v4();
    input.customerId = input.customerId || uuid.v4();
    input.status = input.status || 'ordered';

    orders[input.orderId] = input;

    if (!input.products || _.isEmpty(input.products.product)) {
      throw toSoapError('order must at least contain one product');
    }

    _.each(input.products.product, function(p) {
      if (!p.productId) throw toSoapError('product ID missing');
      if (!productsById[p.productId]) throw toSoapError('invalid product ID: ' + p.productId);
      if (!p.numberOfItems) throw toSoapError('number of items not specified for product ' + p.productId);
    });

    if (!input.shippingAddress) throw toSoapError('shipping address missing');

    if (!input.paymentDetails) throw toSoapError('payment details missing');

    callback({ orderId: input.orderId });
  },
  getOrderDetails: function(input, callback, headers) {
    input = input || {};
    
    if (!orders[input.orderId]) throw toSoapError('invalid order ID: ' + input.orderId);

    callback(orders[input.orderId]);
  },
  cancelOrder: function(input, callback, headers) {
    input = input || {};
    
    if (!orders[input.orderId]) throw toSoapError('invalid order ID: ' + input.orderId);

    delete orders[input.orderId];

    callback();
  }
};

soap.listen(server, '/OrderService/OrderPort', orderPort, wsdl);



// register SOAP endpoints for payment service
var paymentPort = { PaymentService: {} };

paymentPort.PaymentService.PaymentPort = {
  calcTransactionCosts: function(input, callback, headers) {
    input = input || {};

    if (!orders[input.orderId]) throw toSoapError('invalid order ID: ' + input.orderId);

    callback(transactionCosts);
  },
  conductPayment: function(input, callback, headers) {
    input = input || {};

    if (!input.amount) throw toSoapError('amount missing');

    input.amount = parseFloat(input.amount).toFixed(2);

    var order = orders[input.orderId];

    if (!order) throw toSoapError('invalid order ID: ' + input.orderId);

    var total = transactionCosts + shipmentCosts;

    _.each(_.values(order.products.product), function(p) {
      total = total + (productsById[p.productId].price * parseInt(p.numberOfItems));
    });

    if (total > input.amount) throw toSoapError('amount is not enough; must be at least ' + total);

    order.status = 'payed';

    callback(order);
  }
};

soap.listen(server, '/PaymentService/PaymentPort', paymentPort, wsdl);



// register SOAP endpoints for shipment service
var shipmentPort = { ShipmentService: {} };

shipmentPort.ShipmentService.ShipmentPort = {
  calcShipmentCosts: function(input, callback, headers) {
    input = input || {};

    if (!orders[input.orderId]) throw toSoapError('invalid order ID: ' + input.orderId);

    callback(shipmentCosts);
  },
  shipProducts: function(input, callback, headers) {
    input = input || {};

    if (!input.date) throw toSoapError('shipping date missing');

    var order = orders[input.orderId];

    if (!order) throw toSoapError('invalid order ID: ' + input.orderId);

    if (order.status !== 'payed') throw toSoapError('order must be payed before it can be shipped');

    order.status = 'shipped';

    callback(order);
  }
};

soap.listen(server, '/ShipmentService/ShipmentPort', shipmentPort, wsdl);



// init SOAP server
server.listen(soapPort, function(err) {
  if (err) throw err;
});

console.log('server listening on port ' + soapPort);
